##' qSig method
##'
##' @docType methods
##' @name qSig
##' @rdname qSig-methods
##' @aliases qSig,list,character,SummarizedExperiment-method
##' @param qsig When 'gess_method' is “CMAP” or “LINCS”, it should be a list of two elements, which are up and down regulated gene sets of entrez ids.
##'  When 'gess_method' is “gCMAP”, “Fisher” or “Cor”, it should be a matrix representing gene expression profiles (GEPs) of treatment(s). 
##' @param gess_method one of "CMAP", "LINCS", "gCMAP", "Fisher" or "Cor"
##' @param refdb \code{SummarizedExperiment} object, which can be HDF5 backend and loaded via 
##' `loadHDF5SummarizedExperiment` function from the HDF5 datasets saved on disk. 
##' For \code{SummarizedExperiment} object, The 'assays' slot should store a \code{DelayedArray} object consist of genome-wide gene expression 
##' profiles (GEPs) from various drug treatments or genetic perturbations. 
##' It represents reference database that the query signature is searched against. 
##' Can be existing public databases (CMAP or LINCS) or custom database.
##' 
##' `CMAP` HDF5 backend database can be downloaded at \url{http://biocluster.ucr.edu/~yduan004/CMAP_db/cmap.tar.gz}, 
#' untar the file by "tar -xzvf file.tar.gz" command, then load the \code{SummarizedExperiment} object via 
##' `loadHDF5SummarizedExperiment` function. The 'assays' slot of the loaded SummarizedExperiment object contains the logFC scores generated 
##' from differential expression (DE) analysis with `limma` of the original CEL files generated by Affymetrix Chips. 
##' The CMAP Affy data is stored at \url{https://portals.broadinstitute.org/cmap/}.
#' The code used for DE analysis is vailable at \url{http://girke.bioinformatics.ucr.edu/longevityTools/mydoc/mydoc_longevityTools_eDRUG_05.html}
#' 
#' `LINCS` HDF5 backend database can be downloaded at \url{http://biocluster.ucr.edu/~yduan004/LINCS_db/lincs42.tar.gz},
#' untar the file by "tar -xzvf file.tar.gz" command, then load the \code{SummarizedExperiment} object via 
##' `loadHDF5SummarizedExperiment` function.
#' 
##' @return "qSig" object
##' @exportMethod qSig
setMethod("qSig",
    signature(qsig="list", gess_method="character", refdb="SummarizedExperiment"),
    function(qsig, gess_method, refdb){
      ## Validity check of refdb
      if(!is.numeric(as.matrix(assay(refdb)[1,1]))) 
        stop("The value stored in 'assays' slot of 'refdb' should be numeric!")
      if(any(gess_method %in% c("CMAP", "LINCS"))){
        upset = qsig[[1]]
        downset = qsig[[2]]
        se = refdb
        gid_db <- rownames(se)
        ## Validity checks of upset and downset
        if(all(c(!is.character(upset), !is.null(upset)))) 
          stop("upset of 'qsig' slot needs to be ID character vector or NULL")
        if(all(c(!is.character(downset), !is.null(downset)))) 
          stop("downset of 'qsig' slot needs to be ID character vector or NULL")
        if(is.null(upset) & is.null(downset)) 
          stop("both or one of the upset and downset in 'qsig' slot need to be assigned query entrez IDs as character vector")
        
        ## Remove entries in up/down set not present in reference database
        if(!is.null(upset)){
          message(paste(sum(upset %in% gid_db),"/",length(upset), "genes in up set share identifiers with reference database"))
          upset <- upset[upset %in% gid_db]
          if(length(upset)==0) 
            stop("upset shares zero idenifiers with reference database, please set upset of 'qsig' slot as NULL")
        }
        if(!is.null(downset)){
          message(paste(sum(downset %in% gid_db),"/",length(downset), "genes in down set share identifiers with reference database"))
          downset <- downset[downset %in% gid_db]
          if(length(downset)==0) 
            stop("downset shares zero idenifiers with reference database, 
                 please set downset of 'qsig' slot as NULL")
        }
        qsig[[1]] = upset
        qsig[[2]] = downset
      } else
        stop("'gess_method' slot must be one of 'CMAP', 'LINCS', or 'Fisher' if 'qsig' is a 
              list of two elements represent up and down regulated gene sets!")
      new("qSig", qsig=qsig, gess_method=gess_method, refdb=refdb)
    }
)

##' qSig method
##'
##' @docType methods
##' @name qSig
##' @rdname qSig-methods
##' @aliases qSig,matrix,character,SummarizedExperiment-method
##' @return "qSig" object
##' @exportMethod qSig
setMethod("qSig",
    signature(qsig="matrix", gess_method="character", refdb="SummarizedExperiment"),
    function(qsig, gess_method, refdb){
      ## Validity check of refdb
      if(!is.numeric(as.matrix(assay(refdb)[1,1]))) 
        stop("The value stored in 'assays' slot of 'refdb' should be numeric")
      if(any(gess_method %in% c("gCMAP", "Fisher", "Cor"))){
        experiment = qsig
        gid_db <- rownames(refdb)
        if(! is.numeric(experiment[1,1])) 
          stop("The 'qsig' should be a numeric matrix representing genome-wide GEPs from treatments")
        if(is.null(rownames(experiment))) 
          stop("The 'qsig' should be a numeric matrix with rownames as gene Entrez ids representing genome-wide GEPs")
        if(sum(rownames(experiment) %in% gid_db)==0) 
          stop("The rownames of 'qsig' share 0 identifiers with reference database!")
      } else
        stop("'gess_method' slot must be one of 'gCMAP', 'Fisher' or 'Cor' 
             if 'qsig' is a numeric matrix representing genome-wide GEPs from treatments!")
      new("qSig", qsig=qsig, gess_method=gess_method, refdb=refdb)
    }
)

##' @name show
##' @docType methods
##' @rdname show-methods
##' @aliases show,qSig-method
##' @exportMethod show
setMethod("show", signature(object="qSig"),
    function (object) {
      cat("#\n# qSig object used for GESS analysis \n#\n")
      if(is(object@qsig, "list")){
        cat("@qsig", "\t", "up gene set", paste0("(", length(object@qsig[[1]]), "):"), 
            "\t", object@qsig[[1]][seq_len(10)], "... \n")
        cat("     ", "\t", "down gene set", paste0("(", length(object@qsig[[2]]), "):"), 
            "\t", object@qsig[[2]][seq_len(10)], "... \n")
      }
      if(is(object@qsig, "matrix")){
        cat("@qsig\n")
        mat=object@qsig
        print(head(mat,10))
        cat("# ... with", nrow(mat)-10, "more rows\n")
      }
      cat("\n@gess_method", "\t", object@gess_method, "\n")
      cat("\n@refdb", "\t")
      print(object@refdb)
    })

