##' qSig method
##'
##' @docType methods
##' @name qSig
##' @rdname qSig-methods
##' @aliases qSig,list,character,SummarizedExperiment-method
##' @param qsig A list contains gene sets or GEP
##' @param gess_method one of "CMAP","LINCS","gCMAP","Fisher","SP"
##' @param refdb \code{SummarizedExperiment} object or a HDF5 backend \code{SummarizedExperiment} object loaded via 
##' `loadHDF5SummarizedExperiment` function from the HDF5 datasets saved on disk. 
##' For \code{SummarizedExperiment} object, all the assays are \code{DelayedArray} objects consist of genome-wide differential expression profiles (GEPs)
##'  (e.g. log2 ratios or z-scores) from various drug treatments or genetic perturbations. 
##' It represents reference database that the query signature is searched against. 
##' Can be existing public databases (CMAP or LINCS) or custom database.
##' 
##' `CMAP` HDF5 backend database can be downloaded at \url{http://biocluster.ucr.edu/~yduan004/CMAP_db/cmap.tar.gz}, 
#' untar the file by "tar -xzvf file.tar.gz" command, then load the \code{SummarizedExperiment} object via 
##' `loadHDF5SummarizedExperiment` function. The "assays" slot of the loaded SummarizedExperiment object contains the logFC scores generated 
##' from differential expression (DE) analysis with `limma` of the original CEL files generated by Affymetrix Chips. 
##' The CMAP Affy data is stored at \url{https://portals.broadinstitute.org/cmap/}.
#' The code used for DE analysis is vailable at \url{http://girke.bioinformatics.ucr.edu/longevityTools/mydoc/mydoc_longevityTools_eDRUG_05.html}
#' 
#' `LINCS_de_sub` HDF5 backend database can be downloaded at \url{http://biocluster.ucr.edu/~yduan004/LINCS_db/lincs42_sub.tar.gz},
#' untar the file by "tar -xzvf file.tar.gz" command, then load the \code{SummarizedExperiment} object via 
##' `loadHDF5SummarizedExperiment` function.
#' 
##' @return "qSig" object
##' @exportMethod qSig
setMethod("qSig",
          signature(qsig="list", gess_method="character", refdb="SummarizedExperiment"),
          function(qsig, gess_method, refdb){
            ## Validity check of refdb
            if(!is.numeric(as.matrix(assay(refdb)[1,1]))) stop("The value stored in 'assays' slot of 'refdb' should be numeric")
            if(any(gess_method %in% c("CMAP", "LINCS"))){
              upset = qsig[[1]]
              downset = qsig[[2]]
              se = refdb
              gid_db <- rownames(se)
              ## Validity checks of upset and downset
              if(all(c(!is.character(upset), !is.null(upset)))) stop("upset of 'qsig' slot needs to be ID character vector or NULL")
              if(all(c(!is.character(downset), !is.null(downset)))) stop("downset of 'qsig' slot needs to be ID character vector or NULL")
              if(is.null(upset) & is.null(downset)) stop("both or one of the upset and downset in 'qsig' slot need to be assigned query entrez IDs as character vector")
              
              ## Remove entries in up/down set not present in reference database
              if(!is.null(upset)){
                message(paste(sum(upset %in% gid_db),"/",length(upset), "genes in up set share identifiers with reference database"))
                upset <- upset[upset %in% gid_db]
                if(length(upset)==0) stop("upset shares zero idenifiers with reference database, please set upset of 'qsig' slot as NULL")
              }
              if(!is.null(downset)){
                message(paste(sum(downset %in% gid_db),"/",length(downset), "genes in down set share identifiers with reference database"))
                downset <- downset[downset %in% gid_db]
                if(length(downset)==0) stop("downset shares zero idenifiers with reference database, please set downset of 'qsig' slot as NULL")
              }
              qsig[[1]] = upset
              qsig[[2]] = downset
            } else
              stop("'gess_method' slot must be one of 'CMAP', 'LINCS', or 'Fisher' if 'qsig' is a list of two elements represent up and down regulated
                   gene sets!")
            new("qSig", qsig=qsig, gess_method=gess_method, refdb=refdb)
          }
)

##' qSig method
##'
##' @docType methods
##' @name qSig
##' @rdname qSig-methods
##' @aliases qSig,matrix,character,SummarizedExperiment-method
##' @return "qSig" object
##' @exportMethod qSig
setMethod("qSig",
          signature(qsig="matrix", gess_method="character", refdb="SummarizedExperiment"),
          function(qsig, gess_method, refdb){
            ## Validity check of refdb
            if(!is.numeric(as.matrix(assay(refdb)[1,1]))) stop("The value stored in 'assays' slot of 'refdb' should be numeric")
            if(any(gess_method %in% c("gCMAP", "Fisher", "SP"))){
              experiment = qsig
              gid_db <- rownames(refdb)
              if(! is.numeric(experiment[1,1])) stop("The 'qsig' should be a numeric matrix representing genome-wide GEPs from treatments")
              if(is.null(rownames(experiment))) stop("The 'qsig' should be a numeric matrix with rownames as gene Entrez ids representing genome-wide GEPs")
              # message(paste(sum(names(vec) %in% gid_db),"/",length(vec), "genes in 'qsig' slot share identifiers with reference database"))
              # vec = vec[names(vec) %in% gid_db]
              if(sum(rownames(experiment) %in% gid_db)==0) stop("The rownames of 'qsig' share 0 identifiers with reference database!")
            } else
              stop("'gess_method' slot must be one of 'gCMAP', 'Fisher' or 'SP' if 'qsig' is a numeric matrix representing genome-wide GEPs from treatments!")
            new("qSig", qsig=qsig, gess_method=gess_method, refdb=refdb)
          }
)

##' @name show
##' @docType methods
##' @rdname show-methods
##' @aliases show,qSig-method
##' @exportMethod show
setMethod("show", signature(object="qSig"),
          function (object) {
            cat("#\n# qSig object used for GESS analysis \n#\n")
            if(is(object@qsig, "list")){
              cat("@qsig", "\t", "up gene set", paste0("(", length(object@qsig[[1]]), "):"), "\t", object@qsig[[1]][1:10], "... \n")
              cat("     ", "\t", "down gene set", paste0("(", length(object@qsig[[2]]), "):"), "\t", object@qsig[[2]][1:10], "... \n")
            }
            if(is(object@qsig, "matrix")){
              cat("@qsig\n")
              mat=object@qsig
              print(head(mat,10))
              cat("# ... with", nrow(mat)-10, "more rows\n")
            }
            cat("\n@gess_method", "\t", object@gess_method, "\n")
            cat("\n@refdb", "\t")
            print(object@refdb)
          })

